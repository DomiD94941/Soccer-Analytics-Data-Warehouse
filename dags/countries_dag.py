from airflow.sdk import dag, task, task_group, Variable
from airflow.utils.log.logging_mixin import LoggingMixin
from airflow.sensors.base import PokeReturnValue
from airflow.providers.oracle.hooks.oracle import OracleHook


@dag(
    description="Load countries metadata from Football API to Oracle and CSV",
    catchup=False,
    tags=["football", "oracle", "countries"]
)
def football_countries_sync():
    """
    Airflow DAG for loading countries metadata into Oracle.
    Steps:
      1. Create COUNTRIES table (if missing)
      2. Check if football API is available
      3. Fetch and validate list of countries
      4. Transform into table schema
      5. Save results into CSV and Oracle DB
    """

    @task.sql(conn_id="oracle_default")
    def create_countries_table():
        # Creates COUNTRIES table in Oracle if it does not already exist
        # Columns:
        #   COUNTRY_ID  -> primary key, auto-increment
        #   COUNTRY_NAME -> full country name
        #   COUNTRY_CODE -> short code (e.g., "PL", "US")
        return """
        DECLARE
          e_exists EXCEPTION;
          PRAGMA EXCEPTION_INIT(e_exists, -955);
        BEGIN
          EXECUTE IMMEDIATE '
            CREATE TABLE COUNTRIES (
              COUNTRY_ID NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
              COUNTRY_NAME VARCHAR2(100) NOT NULL,
              COUNTRY_CODE VARCHAR2(10)
            )';
        EXCEPTION
          WHEN e_exists THEN NULL;
        END;
        """

    @task.sensor(poke_interval=30, timeout=120)
    def is_api_available() -> PokeReturnValue:
        # Checks if football API is reachable
        # Retries every 30 seconds, fails after 2 minutes
        # Returns API payload as XCom if successful
        import requests
        log = LoggingMixin().log

        api_key = Variable.get("API_KEY")
        url = "https://v3.football.api-sports.io/countries"
        headers = {
            "x-rapidapi-host": "v3.football.api-sports.io",
            "x-rapidapi-key": api_key
        }
        
        try:
            response = requests.get(url, headers=headers)
            log.info("API response status: %s", response.status_code)
            response.raise_for_status()
            payload = response.json()
        except requests.RequestException as e:
            log.warning("API not available yet: %s", e)
            return PokeReturnValue(is_done=False, xcom_value=None)
        
        return PokeReturnValue(is_done=True, xcom_value=payload)

    @task
    def are_countries_exist(countries: dict) -> list:
        # Validates that the API response contains at least one country
        # Raises AirflowSkipException if no data
        from airflow.exceptions import AirflowSkipException

        log = LoggingMixin().log
        available_countries = countries.get("response", [])
        if not available_countries:
            log.warning("No countries found in API response.")
            raise AirflowSkipException("No countries found in API response.")
        
        log.info("Found %d countries", len(available_countries))
        return available_countries

    @task
    def format_countries(available_countries: list[dict]) -> list[dict[str, str]]:
        # Transforms raw API response into rows matching COUNTRIES table schema
        # Example: {"COUNTRY_NAME": "Poland", "COUNTRY_CODE": "PL"}
        formatted = []
        for country in available_countries:
            formatted.append({
                "COUNTRY_NAME": country.get("name"),
                "COUNTRY_CODE": country.get("code")
            })
        return formatted

    @task_group
    def load_countries(formatted_countries: list[dict[str, str]]):
        # Task group for loading data into CSV and Oracle

        @task
        def countries_to_csv(formatted_countries: list[dict[str, str]]) -> str:
            # Saves countries to /tmp/countries.csv
            # Appends only new countries (avoids duplicates)
            import os
            import csv

            path = "/tmp/countries.csv"
            fieldnames = list(formatted_countries[0].keys())

            # Read existing CSV to collect already saved country names
            existing_names = set()
            if os.path.exists(path) and os.path.getsize(path) > 0:
                with open(path, newline="", encoding="utf-8") as f:
                    for row in csv.DictReader(f):
                        existing_names.add(row.get("COUNTRY_NAME", "").strip())

            # Deduplicate batch before writing
            seen_batch = set()
            new_rows = []
            for row in formatted_countries:
                name = row.get("COUNTRY_NAME", "").strip()
                if not name or name in existing_names or name in seen_batch:
                    continue
                seen_batch.add(name)
                new_rows.append(row)

            # Write rows (append mode)
            with open(path, "a", newline="", encoding="utf-8") as f:
                w = csv.DictWriter(f, fieldnames=fieldnames, extrasaction="ignore")
                if f.tell() == 0:
                    w.writeheader()
                if new_rows:
                    w.writerows(new_rows)

            return f"Appended {len(new_rows)} new countries to {path}"

        @task
        def countries_to_oracle(formatted_countries: list[dict[str, str]]) -> str:

            # Inserts countries into Oracle DB using MERGE
            # Skips rows if COUNTRY_NAME already exists
            
            sql = """
                MERGE INTO COUNTRIES t
                USING (
                    SELECT
                        :COUNTRY_NAME AS COUNTRY_NAME,
                        :COUNTRY_CODE AS COUNTRY_CODE
                    FROM dual
                ) s
                ON (t.COUNTRY_NAME = s.COUNTRY_NAME)
                WHEN NOT MATCHED THEN INSERT (
                    COUNTRY_NAME, COUNTRY_CODE
                ) VALUES (
                    s.COUNTRY_NAME, s.COUNTRY_CODE
                )
            """

            hook = OracleHook(oracle_conn_id="oracle_default")
            with hook.get_conn() as conn:
                with conn.cursor() as cur:
                    cur.executemany(sql, formatted_countries)
                    inserted = cur.rowcount or 0
                conn.commit()

            return f"Inserted {inserted} new countries into the database."

        # First write CSV, then insert into Oracle
        countries_to_csv(formatted_countries) >> countries_to_oracle(formatted_countries)

    # DAG flow definition
    create_countries_table()
    countries = is_api_available()
    available_countries = are_countries_exist(countries)
    formatted_countries = format_countries(available_countries)
    load_countries(formatted_countries)


# Instantiate DAG
football_countries_sync()
