from airflow.sdk import dag, task, task_group, Variable
from airflow.utils.log.logging_mixin import LoggingMixin
from airflow.sensors.base import PokeReturnValue
from airflow.providers.oracle.hooks.oracle import OracleHook

@dag
def countries_dag():

    @task.sql(conn_id="oracle_default")
    def create_countries_table():
        """
        Create COUNTRIES table if it does not exist.
        """
        return """
        DECLARE
          e_exists EXCEPTION;
          PRAGMA EXCEPTION_INIT(e_exists, -955);
        BEGIN
          EXECUTE IMMEDIATE '
            CREATE TABLE COUNTRIES (
              COUNTRY_ID NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
              COUNTRY_NAME VARCHAR2(100) NOT NULL,
              COUNTRY_CODE VARCHAR2(10)
            )';
        EXCEPTION
          WHEN e_exists THEN NULL;
        END;
        """

    @task.sensor(poke_interval=30, timeout=120)
    def is_api_available() -> PokeReturnValue:
        """
        Check if the Countries API is available.
        """
        import requests

        log = LoggingMixin().log

        api_key = Variable.get("API_KEY")
        url = "https://v3.football.api-sports.io/countries"
        headers = {
            "x-rapidapi-host": "v3.football.api-sports.io",
            "x-rapidapi-key": api_key
        }
        
        try:
            response = requests.get(url, headers=headers)
            log.info("API response status: %s", response.status_code)
            response.raise_for_status()
            payload = response.json()
        except requests.RequestException as e:
            log.warning("API not available yet: %s", e)
            return PokeReturnValue(is_done=False, xcom_value=None)
        
        return PokeReturnValue(is_done=True, xcom_value=payload)

    @task
    def are_countries_exist(countries: dict) -> list:
        """
        Validate that countries exist in the API response.
        """
        from airflow.exceptions import AirflowSkipException

        log = LoggingMixin().log
        available_countries = countries.get("response", [])
        if not available_countries:
            log.warning("No countries found in API response.")
            raise AirflowSkipException("No countries found in API response.")
        
        log.info("Found %d countries", len(available_countries))
        return available_countries

    @task
    def format_countries(available_countries: list[dict]) -> list[dict[str, str]]:
        """
        Transform raw API payload to table-shaped dicts with column names
        matching the COUNTRIES table schema.
        """
        formatted = []
        for country in available_countries:
            formatted.append({
                "COUNTRY_NAME": country.get("name"),
                "COUNTRY_CODE": country.get("code")
            })
        return formatted

    @task_group
    def load_countries(formatted_countries: list[dict[str, str]]):
        @task
        def countries_to_csv(formatted_countries: list[dict[str, str]]) -> str:
            """
            Append-only CSV writer for COUNTRIES.
            """
            import os
            import csv

            path = "/tmp/countries.csv"

            fieldnames = list(formatted_countries[0].keys())

            existing_names = set()
            if os.path.exists(path) and os.path.getsize(path) > 0:
                with open(path, newline="", encoding="utf-8") as f:
                    for row in csv.DictReader(f):
                        existing_names.add(row.get("COUNTRY_NAME", "").strip())

            seen_batch = set()
            new_rows = []
            for row in formatted_countries:
                name = row.get("COUNTRY_NAME", "").strip()
                if not name or name in existing_names or name in seen_batch:
                    continue
                seen_batch.add(name)
                new_rows.append(row)

            with open(path, "a", newline="", encoding="utf-8") as f:
                w = csv.DictWriter(f, fieldnames=fieldnames, extrasaction="ignore")
                if f.tell() == 0:
                    w.writeheader()
                if new_rows:
                    w.writerows(new_rows)

            return f"Appended {len(new_rows)} new countries to {path}"

        @task
        def countries_to_oracle(formatted_countries: list[dict[str, str]]) -> str:
            """
            Insert-only load into Oracle (skip if COUNTRY_NAME already exists).
            """
            sql = """
                MERGE INTO COUNTRIES t
                USING (
                    SELECT
                        :COUNTRY_NAME AS COUNTRY_NAME,
                        :COUNTRY_CODE AS COUNTRY_CODE
                    FROM dual
                ) s
                ON (t.COUNTRY_NAME = s.COUNTRY_NAME)
                WHEN NOT MATCHED THEN INSERT (
                    COUNTRY_NAME, COUNTRY_CODE
                ) VALUES (
                    s.COUNTRY_NAME, s.COUNTRY_CODE
                )
            """

            hook = OracleHook(oracle_conn_id="oracle_default")
            with hook.get_conn() as conn:
                with conn.cursor() as cur:
                    cur.executemany(sql, formatted_countries)
                    inserted = cur.rowcount or 0
                conn.commit()

            return f"Inserted {inserted} new countries into the database."

        countries_to_csv(formatted_countries) >> countries_to_oracle(formatted_countries)

    create_countries_table()
    countries = is_api_available()
    available_countries = are_countries_exist(countries)
    formatted_countries = format_countries(available_countries)
    load_countries(formatted_countries)

countries_dag()
