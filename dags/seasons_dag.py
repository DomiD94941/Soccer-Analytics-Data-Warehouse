from airflow.sdk import dag, task, task_group, Variable
from airflow.utils.log.logging_mixin import LoggingMixin
from airflow.sensors.base import PokeReturnValue
from airflow.providers.oracle.hooks.oracle import OracleHook

@dag
def seasons_dag():

    @task.sql(conn_id="oracle_default")
    def create_seasons_table():
        """
        Create SEASONS table if it does not exist.
        """

        return """
        DECLARE
          e_exists EXCEPTION;
          PRAGMA EXCEPTION_INIT(e_exists, -955);
        BEGIN
          EXECUTE IMMEDIATE '
            CREATE TABLE SEASONS (
              SEASON_ID NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
              SEASON_YEAR NUMBER NOT NULL
            )';
        EXCEPTION
          WHEN e_exists THEN NULL;
        END;
        """

    @task.sensor(poke_interval=30, timeout=120)
    def is_api_available() -> PokeReturnValue:
        """
        Check if the API is available.
        """
        import requests

        log = LoggingMixin().log

        api_key = Variable.get("API_KEY")
        url = "https://v3.football.api-sports.io/leagues/seasons"
        headers = {
            "x-rapidapi-host": "v3.football.api-sports.io",
            "x-rapidapi-key": api_key   
        }
        
        try:
            response = requests.get(url, headers=headers)
            log.info("API response status: %s", response.status_code)
            response.raise_for_status()
            payload = response.json()
        except requests.RequestException as e:
            log.warning("API not available yet: %s", e)
            return PokeReturnValue(is_done=False, xcom_value=None)
        
        return PokeReturnValue(is_done=True, xcom_value=payload)
    
    @task
    def are_seasons_exist(seasons: dict) -> list:
        """
        Validate that seasons exist in the API response.
        """
        from airflow.exceptions import AirflowSkipException

        log = LoggingMixin().log
        available_seasons = seasons.get("response", [])
        if not available_seasons:
            log.warning("No seasons found in API response.")
            raise AirflowSkipException("No seasons found in API response.")
        
        log.info("Found %d seasons", len(available_seasons))
        return available_seasons

    @task
    def format_seasons(available_seasons: list[int]) -> list[dict[str, int]]:
        """
        Transform raw API payload to table-shaped dicts with column names
        matching the SEASONS table schema.
        """
        return [{"SEASON_ID": i, "SEASON_YEAR": season_year} for i, season_year in enumerate(available_seasons, start=1)]
    
    @task_group
    def load_seasons(formatted_seasons: list[dict[str, int]]):
        @task
        def load_seasons_csv(formatted_seasons: list[dict[str, int]]) -> str:
            """
            Append-only CSV writer for SEASONS:
            - Reads existing SEASON_IDs (if file exists)
            - Appends only NEW rows (skips IDs already present; also dedupes within batch)
            - Writes header once when the file is empty/new
            """
            import os
            import csv

            path = "/tmp/seasons.csv"

            fieldnames = list(formatted_seasons[0].keys())

            existing_ids = set()
            if os.path.exists(path) and os.path.getsize(path) > 0:
                with open(path, newline="", encoding="utf-8") as f:
                    for row in csv.DictReader(f):
                        existing_ids.add(str(row.get("SEASON_ID", "")).strip())

            seen_batch = set()
            new_rows = []
            for row in formatted_seasons:
                season_id = str(row.get("SEASON_ID", "")).strip()
                if not season_id or season_id in existing_ids or season_id in seen_batch:
                    continue
                seen_batch.add(season_id)
                new_rows.append(row)

            with open(path, "a", newline="", encoding="utf-8") as f:
                w = csv.DictWriter(f, fieldnames=fieldnames, extrasaction="ignore")
                if f.tell() == 0:
                    w.writeheader()
                if new_rows:
                    w.writerows(new_rows)

            return f"Appended {len(new_rows)} new seasons to {path}"

        @task
        def load_seasons_oracle_db(formatted_seasons: list[dict[str, int]]) -> str:
            """
            Insert-only load into Oracle (skip if SEASON_ID already exists):
            - Uses MERGE with only WHEN NOT MATCHED (no update clause)
            - Works idempotently across multiple DAG runs
            - executemany with named binds for efficiency
            """

            sql = """
                MERGE INTO SEASONS t
                USING (
                    SELECT
                        :SEASON_ID AS SEASON_ID,
                        :SEASON_YEAR AS SEASON_YEAR
                    FROM dual
                ) s
                ON (t.SEASON_ID = s.SEASON_ID)
                WHEN NOT MATCHED THEN INSERT (
                    SEASON_ID, SEASON_YEAR
                ) VALUES (
                    s.SEASON_ID, s.SEASON_YEAR
                )
            """

            hook = OracleHook(oracle_conn_id="oracle_default")
            with hook.get_conn() as conn:
                with conn.cursor() as cur:
                    cur.executemany(sql, formatted_seasons)
                    inserted = cur.rowcount or 0
                conn.commit()

            return f"Inserted {inserted} new seasons into the database."

        load_seasons_csv(formatted_seasons) >> load_seasons_oracle_db(formatted_seasons)

    create_seasons_table() 
    seasons = is_api_available()
    available_seasons = are_seasons_exist(seasons)
    formatted_seasons = format_seasons(available_seasons)
    load_seasons(formatted_seasons)

seasons_dag()

