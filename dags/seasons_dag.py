from airflow.sdk import dag, task, task_group, Variable
from airflow.utils.log.logging_mixin import LoggingMixin
from airflow.sensors.base import PokeReturnValue
from airflow.providers.oracle.hooks.oracle import OracleHook


@dag(
    description="Load seasons from Football API into Oracle + CSV (free/paid aware).",
    catchup=False,
    tags=["football", "oracle", "seasons"]
)
def football_seasons_sync():
    """
    Airflow DAG for loading football seasons into Oracle.
    Steps:
      1. Create SEASONS table (if missing)
      2. Check if API /leagues/seasons is available
      3. Validate seasons from API
      4. Branch based on subscription plan:
         - Free plan -> fixed years [2021, 2022, 2023]
         - Paid plan -> use API seasons
      5. Load seasons into CSV + Oracle
    """

    @task.sql(conn_id="oracle_default")
    def create_seasons_table():
        # Creates SEASONS table if it doesnâ€™t exist
        # Columns:
        #   SEASON_ID   -> surrogate key (auto-generated)
        #   SEASON_YEAR -> year (e.g. 2023)
        return """
        DECLARE
          e_exists EXCEPTION;
          PRAGMA EXCEPTION_INIT(e_exists, -955);
        BEGIN
          EXECUTE IMMEDIATE '
            CREATE TABLE SEASONS (
              SEASON_ID NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
              SEASON_YEAR NUMBER NOT NULL
            )';
        EXCEPTION
          WHEN e_exists THEN NULL;
        END;
        """

    @task.sensor(poke_interval=30, timeout=120)
    def is_api_available() -> PokeReturnValue:
        # Sensor: check if football API /leagues/seasons endpoint is available
        # Retries every 30s, times out after 2 minutes
        import requests
        log = LoggingMixin().log

        api_key = Variable.get("API_KEY")
        url = "https://v3.football.api-sports.io/leagues/seasons"
        headers = {
            "x-rapidapi-host": "v3.football.api-sports.io",
            "x-rapidapi-key": api_key   
        }
        
        try:
            response = requests.get(url, headers=headers)
            log.info("API response status: %s", response.status_code)
            response.raise_for_status()
            payload = response.json()
        except requests.RequestException as e:
            log.warning("API not available yet: %s", e)
            return PokeReturnValue(is_done=False, xcom_value=None)
        
        return PokeReturnValue(is_done=True, xcom_value=payload)
    
    @task
    def are_seasons_exist(payload: dict) -> list:
        # Validate API response contains at least one season
        # Raises AirflowSkipException if empty
        from airflow.exceptions import AirflowSkipException
        log = LoggingMixin().log

        available_seasons = payload.get("response", [])
        if not available_seasons:
            log.warning("No seasons found in API response.")
            raise AirflowSkipException("No seasons found in API response.")
        
        log.info("Found %d seasons", len(available_seasons))
        return available_seasons
    
    @task.branch
    def choose_plan() -> str:
        # Branching task: decides which path to take based on subscription plan
        # - Free plan -> call format_seasons_free_plan
        # - Paid plan -> call format_seasons_paid_plan
        import requests
        log = LoggingMixin().log
        api_key = Variable.get("API_KEY")
        headers = {
            "x-rapidapi-host": "v3.football.api-sports.io",
            "x-rapidapi-key": api_key   
        }
        try:
            r = requests.get(f"{api_key}/status", headers=headers, timeout=15)
            r.raise_for_status()
            plan = r.json()["response"]["subscription"]["plan"]
        except Exception as exc:
            log.warning("Failed to get subscription plan: %s", exc)
            return format_seasons_free_plan.__name__

        if str(plan).lower() == "free":
            return format_seasons_free_plan.__name__
        else:
            return format_seasons_paid_plan.__name__
        
    @task
    def format_seasons_free_plan() -> list[dict[str, int]]:
        # For free plan: return fixed list of seasons
        fixed = [2021, 2022, 2023]
        return [{"SEASON_ID": i, "SEASON_YEAR": year} for i, year in enumerate(fixed, start=1)]

    @task
    def format_seasons_paid_plan(available_seasons: list[int]) -> list[dict[str, int]]:
        # For paid plan: transform API seasons into SEASONS table schema
        return [{"SEASON_ID": i, "SEASON_YEAR": year} for i, year in enumerate(available_seasons, start=1)]

    @task_group
    def load_seasons(formatted_seasons: list[dict[str, int]]):
        # Task group: save seasons into CSV + Oracle DB

        @task
        def seasons_to_csv(formatted_seasons: list[dict[str, int]]) -> str:
            # Append-only writer for /tmp/seasons.csv
            # Skips duplicates (based on SEASON_ID)
            import os, csv
            path = "/tmp/seasons.csv"
            fieldnames = list(formatted_seasons[0].keys())

            # Collect already existing IDs
            existing_ids = set()
            if os.path.exists(path) and os.path.getsize(path) > 0:
                with open(path, newline="", encoding="utf-8") as f:
                    for row in csv.DictReader(f):
                        existing_ids.add(str(row.get("SEASON_ID", "")).strip())

            # Deduplicate within batch
            seen_batch, new_rows = set(), []
            for row in formatted_seasons:
                season_id = str(row.get("SEASON_ID", "")).strip()
                if not season_id or season_id in existing_ids or season_id in seen_batch:
                    continue
                seen_batch.add(season_id)
                new_rows.append(row)

            # Write new rows
            with open(path, "a", newline="", encoding="utf-8") as f:
                w = csv.DictWriter(f, fieldnames=fieldnames, extrasaction="ignore")
                if f.tell() == 0:
                    w.writeheader()
                if new_rows:
                    w.writerows(new_rows)

            return f"Appended {len(new_rows)} new seasons to {path}"

        @task
        def seasons_to_oracle(formatted_seasons: list[dict[str, int]]) -> str:
            
            # Inserts seasons into Oracle SEASONS table
            # MERGE ensures duplicates are skipped

            sql = """
                MERGE INTO SEASONS t
                USING (
                    SELECT
                        :SEASON_ID AS SEASON_ID,
                        :SEASON_YEAR AS SEASON_YEAR
                    FROM dual
                ) s
                ON (t.SEASON_ID = s.SEASON_ID)
                WHEN NOT MATCHED THEN INSERT (
                    SEASON_ID, SEASON_YEAR
                ) VALUES (
                    s.SEASON_ID, s.SEASON_YEAR
                )
            """

            hook = OracleHook(oracle_conn_id="oracle_default")
            with hook.get_conn() as conn:
                with conn.cursor() as cur:
                    cur.executemany(sql, formatted_seasons)
                    inserted = cur.rowcount or 0
                conn.commit()

            return f"Inserted {inserted} new seasons into the database."

        (formatted_seasons) >> seasons_to_oracle(formatted_seasons)

    # DAG wiring (task dependencies)
    create_seasons_table() 
    seasons = is_api_available()
    available_seasons = are_seasons_exist(seasons)
    branch = choose_plan()
    branch >> load_seasons(format_seasons_free_plan())
    branch >> load_seasons(format_seasons_paid_plan(available_seasons))


football_seasons_sync()
